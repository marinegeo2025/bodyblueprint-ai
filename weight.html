<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>本来の面目, Honrai No Menmoku - Weight Tracking</title>
  <link rel="stylesheet" href="styles.css" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Luxon & Chart.js time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>

  <style>
    /* Make sure the chart container scales nicely */
    #weightChart {
      width: 100%;
      max-height: 600px;
    }
    /* Simple responsive helper for the canvas container */
    .chart-container {
      position: relative;
      width: 100%;
      max-width: 800px; /* Adjust as desired */
      margin: 0 auto;   /* Center it */
    }
  </style>
</head>
<body>
  <nav>
    <ul>
      <li><a href="index.html">家 Home</a></li>
        <li><a href="bmr.html">強 BMR</a></li>
        <li><a href="weight.html">落 Weight</a></li>
        <li><a href="meals.html">食 Meals</a></li>
        <li><a href="chat.html">話 AI Chat</a></li>
    </ul>
  </nav>

  <main>
    <section id="weight" class="page">
      <h1>Weight Tracking</h1>
      <button id="resetWeightButton" class="reset-btn">Reset Weight Data</button>

      <!-- Responsive Chart Container -->
      <div class="chart-container">
        <canvas id="weightChart"></canvas>
      </div>

      <br><br>

      <!-- Weight input form -->
      <form id="weightForm">
        <label for="weightInput">Enter Weight (kg):</label><br>
        <input type="number" id="weightInput" step="0.1" required /><br><br>

        <label for="dateInput">Date:</label><br>
        <input type="date" id="dateInput" required /><br><br>

        <label for="notes">Notes:</label><br>
        <input type="text" id="notes" placeholder="E.g., morning weigh-in" /><br><br>

        <button type="submit">Add Weight</button>
      </form>

      <h2>Weight Records</h2>
      <table id="weightTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Weight (kg)</th>
            <th>Weekly Avg</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows added dynamically -->
        </tbody>
      </table>
    </section>
  </main>

  <footer>
    <p>本来の面目, Honrai No Menmoku &copy; 2025</p>
  </footer>

  <script>
    // Handle form submission
    document.getElementById("weightForm").addEventListener("submit", function (event) {
      event.preventDefault();

      const weight = parseFloat(document.getElementById("weightInput").value);
      const notes = document.getElementById("notes").value;
      let dateVal = document.getElementById("dateInput").value;
      // If user didn't pick a date, default to today's date
      if (!dateVal) {
        dateVal = new Date().toISOString().split("T")[0];
      }

      let weightData = JSON.parse(localStorage.getItem("weightData")) || [];
      // Create a new entry
      weightData.push({ date: dateVal, weight, notes });
      // Save to localStorage
      localStorage.setItem("weightData", JSON.stringify(weightData));

      // Reset form fields
      document.getElementById("weightInput").value = "";
      document.getElementById("notes").value = "";
      document.getElementById("dateInput").value = "";

      // Update UI
      updateWeightTable();
      updateChart();
    });

    // Render the table with each weight entry in its own row
    function updateWeightTable() {
      const tbody = document.querySelector("#weightTable tbody");
      tbody.innerHTML = "";

      let weightData = JSON.parse(localStorage.getItem("weightData")) || [];
      // Sort entries by date (ascending)
      weightData.sort((a, b) => new Date(a.date) - new Date(b.date));

      // Calculate rolling "weekly average" for each entry
      for (let i = 0; i < weightData.length; i++) {
        let weeklyAvg = "-";
        // For the last 7 entries (including current)
        if (i >= 6) {
          let slice = weightData.slice(i - 6, i + 1);
          let sum = slice.reduce((acc, item) => acc + item.weight, 0);
          weeklyAvg = (sum / slice.length).toFixed(1);
        }

        // Build a table row
        const row = document.createElement("tr");

        // Date cell with editable <input type="date">
        const dateCell = document.createElement("td");
        const dateInput = document.createElement("input");
        dateInput.type = "date";
        dateInput.value = weightData[i].date;
        dateInput.addEventListener("change", () => {
          weightData[i].date = dateInput.value;
          localStorage.setItem("weightData", JSON.stringify(weightData));
          updateWeightTable();
          updateChart();
        });
        dateCell.appendChild(dateInput);
        row.appendChild(dateCell);

        // Weight cell
        const weightCell = document.createElement("td");
        weightCell.textContent = weightData[i].weight;
        row.appendChild(weightCell);

        // Weekly average cell
        const weeklyAvgCell = document.createElement("td");
        weeklyAvgCell.textContent = weeklyAvg;
        row.appendChild(weeklyAvgCell);

        // Notes cell
        const notesCell = document.createElement("td");
        notesCell.textContent = weightData[i].notes || "";
        row.appendChild(notesCell);

        tbody.appendChild(row);
      }
    }

    // Build/update the chart with a time-based x-axis
    function updateChart() {
      let weightData = JSON.parse(localStorage.getItem("weightData")) || [];
      if (weightData.length === 0) return;

      // 1) Sort by date ascending
      weightData.sort((a, b) => new Date(a.date) - new Date(b.date));

      // 2) Identify earliest & latest dates in the dataset
      const earliestDate = new Date(weightData[0].date);
      const latestDate   = new Date(weightData[weightData.length - 1].date);

      // 3) Extend the x-axis by 1 month after the latest date
      const xAxisMax = new Date(latestDate);
      xAxisMax.setMonth(xAxisMax.getMonth() + 1);

      // 4) Build a daily map of weights for the actual data
      const dailyMap = {};
      weightData.forEach(item => {
        if (!dailyMap[item.date]) {
          dailyMap[item.date] = [];
        }
        dailyMap[item.date].push(item.weight);
      });

      // 5) Create array of daily data from earliestDate to xAxisMax
      let currentDay = new Date(earliestDate);
      const dailyData = [];
      while (currentDay <= xAxisMax) {
        const isoStr = currentDay.toISOString().split("T")[0];
        let avg = null;
        if (dailyMap[isoStr]) {
          const sum = dailyMap[isoStr].reduce((a, b) => a + b, 0);
          avg = sum / dailyMap[isoStr].length;
        }
        dailyData.push({
          x: new Date(currentDay), // Date object for Chart.js time scale
          y: avg
        });
        currentDay.setDate(currentDay.getDate() + 1);
      }

      // 6) Compute linear regression for valid (non-null) points
      const validPoints = [];
      dailyData.forEach((pt, i) => {
        if (pt.y !== null) {
          validPoints.push({ xIndex: i, y: pt.y });
        }
      });

      // Basic linear regression function
      function linearRegression(points) {
        if (points.length < 2) {
          // Not enough data for slope; just return a constant line
          return { slope: 0, intercept: points[0]?.y || 0 };
        }
        const n = points.length;
        const sumX = points.reduce((acc, p) => acc + p.xIndex, 0);
        const sumY = points.reduce((acc, p) => acc + p.y, 0);
        const sumXY = points.reduce((acc, p) => acc + p.xIndex * p.y, 0);
        const sumX2 = points.reduce((acc, p) => acc + p.xIndex**2, 0);

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX**2);
        const intercept = (sumY - slope * sumX) / n;
        return { slope, intercept };
      }

      const { slope, intercept } = linearRegression(validPoints);

      // 7) Build trendline array for the entire daily range
      const trendlineData = dailyData.map((pt, i) => {
        const predictedY = slope * i + intercept;
        return { x: pt.x, y: predictedY };
      });

      // 8) Destroy old chart if it exists
      const ctx = document.getElementById("weightChart").getContext("2d");
      if (window.myChart) {
        window.myChart.destroy();
      }

      // (Optional) Y-axis range around the last weight
      // let lastWeight = weightData[weightData.length - 1].weight;
      // let yMin = lastWeight - 5;
      // let yMax = lastWeight + 5;

      // 9) Create new Chart.js line chart with time-based x-axis
      window.myChart = new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            {
              label: "Daily Avg Weight",
              data: dailyData, // array of { x: Date, y: number|null }
              borderColor: "blue",
              fill: false,
              pointStyle: "circle",
              pointRadius: 3,
              borderWidth: 2,
              spanGaps: false // missing data => breaks in the line
            },
            {
              label: "Trendline",
              data: trendlineData,
              borderColor: "red",
              borderDash: [5, 5],
              fill: false,
              borderWidth: 2,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: "time",
              time: {
                unit: "day",
                displayFormats: {
                  day: "dd-LL"
                  // or "DD-MM", "dd LLL", etc.
                }
              },
              min: earliestDate,
              max: xAxisMax,
              ticks: {
                autoSkip: true,
                maxRotation: 30,
                minRotation: 30
              },
              grid: {
                display: true,
                color: "rgba(200, 200, 200, 0.5)"
              }
            },
            y: {
              // beginAtZero: false,
              // OPTIONAL fixed range:
              // min: yMin,
              // max: yMax,
              grid: {
                display: true,
                color: "rgba(180, 180, 180, 0.7)"
              }
            }
          }
        }
      });
    }

    // On load, populate table and chart
    window.onload = function () {
      updateWeightTable();
      updateChart();
    };

    // Reset all weight data
    document.getElementById("resetWeightButton").addEventListener("click", function() {
      if (confirm("Are you sure you want to delete all weight data? This cannot be undone.")) {
        localStorage.removeItem("weightData");
        document.querySelector("#weightTable tbody").innerHTML = "";
        if (window.myChart) {
          window.myChart.destroy();
        }
        alert("Weight data has been cleared.");
      }
    });
  </script>
</body>
</html>
