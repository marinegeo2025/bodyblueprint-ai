<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>本来の面目, Honrai No Menmoku - Weight Tracking</title>
  <link rel="stylesheet" href="styles.css" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Luxon & Chart.js time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>

  <style>
    /* Make sure the chart container scales nicely */
    #weightChart {
      width: 100%;
      max-height: 600px;
    }
    /* Simple responsive helper for the canvas container */
    .chart-container {
      position: relative;
      width: 100%;
      max-width: 800px; /* Adjust as desired */
      margin: 0 auto;   /* Center it */
    }
  </style>
</head>
<body>
  <nav>
    <ul>
      <li><a href="index.html">家 Home</a></li>
        <li><a href="bmr.html">強 BMR</a></li>
        <li><a href="weight.html">落 Weight</a></li>
        <li><a href="meals.html">食 Meals</a></li>
        <li><a href="chat.html">話 AI Chat</a></li>
    </ul>
  </nav>

  <main>
    <section id="weight" class="page">
      <h1>Weight Tracking</h1>
      <button id="resetWeightButton" class="reset-btn">Reset Weight Data</button>

      <!-- Responsive Chart Container -->
      <div class="chart-container">
        <canvas id="weightChart"></canvas>
      </div>

      <br><br>

      <!-- Weight input form -->
      <form id="weightForm">
        <label for="weightInput">Enter Weight (kg):</label><br>
        <input type="number" id="weightInput" step="0.1" required /><br><br>

        <label for="dateInput">Date:</label><br>
        <input type="date" id="dateInput" required /><br><br>

        <label for="notes">Notes:</label><br>
        <input type="text" id="notes" placeholder="E.g., morning weigh-in" /><br><br>

        <button type="submit">Add Weight</button>
      </form>

      <h2>Weight Records</h2>
      <table id="weightTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Weight (kg)</th>
            <th>Weekly Avg</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows added dynamically -->
        </tbody>
      </table>
    </section>
  </main>

  <footer>
    <p>本来の面目, Honrai No Menmoku &copy; 2025</p>
  </footer>

  <script>
  // Handle form submission
  document.getElementById("weightForm").addEventListener("submit", function (event) {
    event.preventDefault();
    
    const weight = parseFloat(document.getElementById("weightInput").value);
    const notes = document.getElementById("notes").value;
    let dateVal = document.getElementById("dateInput").value;
    // If user didn't pick a date, default to today's date
    if (!dateVal) {
      dateVal = new Date().toISOString().split("T")[0];
    }

    let weightData = JSON.parse(localStorage.getItem("weightData")) || [];
    // Append new weight entry
    weightData.push({ date: dateVal, weight, notes });
    localStorage.setItem("weightData", JSON.stringify(weightData));

    // Reset form fields
    document.getElementById("weightInput").value = "";
    document.getElementById("notes").value = "";
    document.getElementById("dateInput").value = "";

    updateWeightTable();
    updateChart();
  });

  // Render the table with each weight entry in its own row (with a delete button)
  window.updateWeightTable = function() {
    const tbody = document.querySelector("#weightTable tbody");
    tbody.innerHTML = "";

    let weightData = JSON.parse(localStorage.getItem("weightData")) || [];
    // Sort entries by date ascending
    weightData.sort((a, b) => new Date(a.date) - new Date(b.date));

    weightData.forEach((entry, index) => {
      const row = document.createElement("tr");

      // Date cell with editable input
      const dateCell = document.createElement("td");
      const dateInput = document.createElement("input");
      dateInput.type = "date";
      dateInput.value = entry.date;
      dateInput.addEventListener("change", () => {
        weightData[index].date = dateInput.value;
        localStorage.setItem("weightData", JSON.stringify(weightData));
        updateWeightTable();
        updateChart();
      });
      dateCell.appendChild(dateInput);
      row.appendChild(dateCell);

      // Weight cell
      const weightCell = document.createElement("td");
      weightCell.textContent = entry.weight;
      row.appendChild(weightCell);

      // Weekly average cell
      const weeklyAvgCell = document.createElement("td");
      // Calculate average for entries on the same date
      const sameDateEntries = weightData.filter(e => e.date === entry.date);
      let avgForDate = sameDateEntries.reduce((acc, e) => acc + e.weight, 0) / sameDateEntries.length;
      weeklyAvgCell.textContent = avgForDate.toFixed(1);
      row.appendChild(weeklyAvgCell);

      // Notes cell
      const notesCell = document.createElement("td");
      notesCell.textContent = entry.notes || "";
      row.appendChild(notesCell);

      // Delete button cell
      const deleteCell = document.createElement("td");
      const deleteButton = document.createElement("button");
      deleteButton.textContent = "x";
      deleteButton.style.color = "ffffff";
      deleteButton.style.cursor = "pointer";
      deleteButton.title = "Delete this entry";
      deleteButton.addEventListener("click", () => {
        if (confirm("Are you sure you want to delete this weight entry?")) {
          weightData.splice(index, 1);
          localStorage.setItem("weightData", JSON.stringify(weightData));
          updateWeightTable();
          updateChart();
        }
      });
      deleteCell.appendChild(deleteButton);
      row.appendChild(deleteCell);

      tbody.appendChild(row);
    });
  };

  // Build/update the chart with a time-based x-axis
  function updateChart() {
  let weightData = JSON.parse(localStorage.getItem("weightData")) || [];
  if (weightData.length === 0) return;

  // Sort entries by date ascending
  weightData.sort((a, b) => new Date(a.date) - new Date(b.date));

  // Earliest and latest date in the data
  const earliestDate = new Date(weightData[0].date);
  const latestDate = new Date(weightData[weightData.length - 1].date);

  // Extend x-axis by ~1 month beyond the latest data point
  const endDate = new Date(latestDate);
  endDate.setMonth(endDate.getMonth() + 1);

  // Build a daily map of weights
  const dailyMap = {};
  weightData.forEach(item => {
    if (!dailyMap[item.date]) {
      dailyMap[item.date] = [];
    }
    dailyMap[item.date].push(item.weight);
  });

  // Generate a chronological list of dates from earliestDate to endDate
  const dates = [];
  let tempDate = new Date(earliestDate);
  while (tempDate <= endDate) {
    dates.push(tempDate.toISOString().split("T")[0]);
    tempDate.setDate(tempDate.getDate() + 1);
  }

  // For each date, compute the average weight or null if no data
  const avgWeights = dates.map(dateStr => {
    if (dailyMap[dateStr]) {
      const sum = dailyMap[dateStr].reduce((a, b) => a + b, 0);
      return (sum / dailyMap[dateStr].length).toFixed(1);
    }
    return null;
  });

  // Create a linear regression trendline
  function linearRegression(xVals, yVals) {
    const validPoints = [];
    yVals.forEach((val, i) => {
      if (val !== null) {
        validPoints.push({ x: i, y: parseFloat(val) });
      }
    });
    if (validPoints.length < 2) return yVals; // Not enough data to compute slope

    const n = validPoints.length;
    const sumX = validPoints.reduce((acc, p) => acc + p.x, 0);
    const sumY = validPoints.reduce((acc, p) => acc + p.y, 0);
    const sumXY = validPoints.reduce((acc, p) => acc + p.x * p.y, 0);
    const sumX2 = validPoints.reduce((acc, p) => acc + p.x * p.x, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    // Build predicted array for each day
    return yVals.map((val, i) => slope * i + intercept);
  }

  const trendline = linearRegression(dates, avgWeights);

  // Build x-axis labels in DD-MM format
  const formattedDates = dates.map(dateStr => {
    const parts = dateStr.split("-");
    return `${parts[2]}-${parts[1]}`; // e.g., "DD-MM"
  });

  // Destroy any existing chart
  const ctx = document.getElementById("weightChart").getContext("2d");
  if (window.myChart) {
    window.myChart.destroy();
  }

  // Create new line chart
  window.myChart = new Chart(ctx, {
    type: "line",
    data: {
      labels: formattedDates,
      datasets: [
        {
          label: "Daily Avg Weight",
          data: avgWeights,
          borderColor: "blue",
          fill: false,
          pointStyle: "circle",
          pointRadius: 3,
          borderWidth: 2,
          spanGaps: false,
        },
        {
          label: "Trendline",
          data: trendline,
          borderColor: "red",
          borderDash: [5, 5],
          fill: false,
          borderWidth: 2,
          spanGaps: true,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            autoSkip: true,
            maxRotation: 30,
            minRotation: 30,
          },
          grid: {
            display: true,
            color: "rgba(200, 200, 200, 0.5)",
          },
        },
        y: {
          beginAtZero: false,
          grid: {
            display: true,
            color: "rgba(180, 180, 180, 0.7)",
          },
        },
      },
    },
  });
}

  // On page load, restore the table and chart
  window.onload = function () {
    updateWeightTable();
    updateChart();
  };

  // Reset button for weight data
  document.getElementById("resetWeightButton").addEventListener("click", function() {
    if (confirm("Are you sure you want to delete all weight data? This cannot be undone.")) {
      localStorage.removeItem("weightData");
      document.querySelector("#weightTable tbody").innerHTML = "";
      if (window.myChart) {
        window.myChart.destroy();
      }
      alert("Weight data has been cleared.");
    }
  });
</script>
</body>
</html>